# Azure Functions

Azure Functions is a serverless compute service that lets you run event-driven code without managing infrastructure. 
It's ideal for lightweight, modular tasks triggered by events like 

- HTTP requests,
- timers, or 
- cloud service changes.

It’s designed for 

- event-driven, 
- stateless, and
- short-lived tasks,

making it ideal for microservices, automation, and reactive workflows.

## What Is Azure Functions?

Azure Functions is part of **Microsoft Azure’s serverless offerings**. 
It allows developers to write small pieces of code ("functions") **that execute in response to events**. 
These functions **automatically scale** and only **consume resources while running**, making them cost-effective and efficient.

### Why Use Azure Functions?

- **No server management:** You don’t need to provision or maintain servers.

- **Event-driven execution:** Functions respond to triggers like HTTP requests, queue messages, or file uploads.

- **Cost efficiency:** You pay only for the time your code runs.

- **Rapid development:** Focus on business logic without worrying about infrastructure.

### Common Use Cases

- **API endpoints:** Lightweight HTTP-triggered functions for microservices or REST APIs.

- **Data processing:** **React to changes** in databases, blob storage, or queues.

- **Scheduled tasks:** Cron-like jobs for cleanup, reporting, or notifications.

- **IoT and telemetry:** Handle device messages or sensor data.

- **Workflow automation:** Trigger actions based on business events (e.g., invoice received → send email).

| **Category**       | **Example**                                                   |
|---------------------|---------------------------------------------------------------|
| **API endpoints**   | Lightweight REST APIs, webhook handlers                       |
| **Data processing** | Blob ingestion, queue-based ETL, telemetry pipelines          |
| **Automation**      | Invoice validation, email dispatch, cleanup jobs              |
| **IoT**             | Sensor data ingestion, device event handling                  |
| **DevOps**          | CI/CD hooks, alerting, provisioning scripts                   |
| **AI orchestration**| Trigger RAG workflows, semantic extraction, validation        |

### Pros

- **Scalability:** Automatically scales based on demand.

- **Language flexibility:** Supports C#, JavaScript, Python, Java, PowerShell, and more.

-  **Integration:** Built-in bindings for Azure services like Cosmos DB, Event Grid, and Service Bus.

-  **Fast deployment:** Ideal for rapid prototyping and agile workflows.

-  **Durable Functions:** Enables stateful workflows with checkpoints.



### Cons

- **Cold start latency:** Latency on first invocation (esp. in Consumption plan).

- **Limited execution time:** Consumption plan functions have a timeout (default 5 minutes).

- **Complex debugging:** Distributed, event-driven architecture can complicate tracing.

- **Vendor lock-in:** Deep integration with Azure services may reduce portability.

- **Limited local state:** Stateless by design; use external storage for persistence.


## When to Use vs. Avoid

### Use Azure Functions when:

- You need lightweight, short-lived tasks.

- Your workload is event-driven and sporadic.

- You want to minimize infrastructure overhead.

### Avoid Azure Functions when:

- You need long-running processes or persistent state.

- You require fine-grained control over runtime and environment.

- Cold start latency is unacceptable for your use case.

---

## Strategic Fit for Your Architecture

- Given your expertise in modular document intelligence workflows, Azure Functions can be a powerful tool for:
 
- Semantic extraction triggers: Fire on blob upload or queue message.

- Contextual validation: Modular validators per vendor/invoice type.

- Audit-friendly dispatch: Email workflows with retry metadata and summary metrics.

- RAG orchestration: Trigger LangChain flows from Service Bus or Event Grid.

---

# Use Case: Invoice Validation with Audit Logging

- **Trigger:** Blob upload or Service Bus message Functionality:

- Parse invoice metadata (vendor, amount, date)

- Validate against business rules

- Log audit trail (status, timestamp, retry count)

- Emit result to downstream queue or storage

##

## Hello World

```javascript

import { app } from '@azure/functions';

export async function helloHttp(request, context) {
    context.log('Processing request...');
    const name = request.query.get('name') || (await request.text());
  
    return {
      status: 200,
      body: `Hello, ${name || 'world'}!`
    };
  }
  
  app.http('helloHttp', {
    methods: ['GET', 'POST'],
    authLevel: 'anonymous',
    handler: helloHttp
  });
  
```

Then hit:

    http://localhost:7071/api/helloHttp?name=Siva

 
## Key Improvements:

- Structured Logging — context.log.error() makes it easier to spot errors in Application Insights.

- Axios-Specific Error Details — If you’re using axios, error.response?.data and error.response?.status help diagnose remote API failures.

- JSON Response — Azure Functions return objects automatically serialized, but specifying Content-Type ensures clarity.

- Avoid Leaking Sensitive Info — You only expose error.message, not full internals or tokens.

## authCallBackHttp Trigger

```javascript
import { app } from '@azure/functions';
import axios from 'axios';
import jwt from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';

const KEYCLOAK_URL = process.env.KEYCLOAK_URL;
const REALM = process.env.KEYCLOAK_REALM;
const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;
const REDIRECT_URI = process.env.REDIRECT_URI;

// JWKS client
const client = jwksClient({
  jwksUri: `${KEYCLOAK_URL}/realms/${REALM}/protocol/openid-connect/certs`,
});

const getKey = (header, callback) => client.getSigningKey(header.kid, (err, key) => {
  if (err) return callback(err);
  callback(null, key.getPublicKey());
});

// Exchange code or refresh token
const exchangeToken = async params => {
  const res = await axios.post(
    `${KEYCLOAK_URL}/realms/${REALM}/protocol/openid-connect/token`,
    new URLSearchParams(params).toString(),
    { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
  );
  return res.data;
};

// Validate JWT
const validateToken = token =>
  new Promise((resolve, reject) => {
    jwt.verify(token, getKey, { algorithms: ['RS256'] }, (err, decoded) =>
      err ? reject(err) : resolve(decoded)
    );
  });

// Refresh access token if expired
const refreshIfExpired = async (accessToken, refreshToken) => {
  try {
    const decoded = await validateToken(accessToken);
    return { accessToken, refreshToken, user: decoded };
  } catch (err) {
    if (err.name === 'TokenExpiredError' && refreshToken) {
      const tokenData = await exchangeToken({
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET,
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
      });
      const decodedNew = await validateToken(tokenData.access_token);
      return {
        accessToken: tokenData.access_token,
        refreshToken: tokenData.refresh_token || refreshToken,
        user: decodedNew,
      };
    } else {
      throw err;
    }
  }
};

// Azure Function
app.http('authCallback', {
  methods: ['POST'],
  authLevel: 'anonymous',
  handler: async (req, res) => {
    const { code, refresh_token } = req.body || {};

    if (!code && !refresh_token)
      return res.status(400).send({ error: 'Provide code or refresh_token' });

    try {
      let tokenData;

      if (code) {
        // Exchange code for tokens
        tokenData = await exchangeToken({
          client_id: CLIENT_ID,
          client_secret: CLIENT_SECRET,
          grant_type: 'authorization_code',
          code,
          redirect_uri: REDIRECT_URI,
        });
      } else {
        tokenData = { access_token: '', refresh_token };
      }

      const result = await refreshIfExpired(tokenData.access_token, tokenData.refresh_token);

      res.status(200).send({
        message: 'Token valid',
        user: result.user,
        access_token: result.accessToken,
        refresh_token: result.refreshToken,
      });
    } catch (err) {
      res.status(401).send({ error: 'Token validation failed', details: err.message });
    }
  },
});



```

local.settings.json or Azure portal:

```json
{
  "IsEncrypted": false,
  "Values": {
    "FUNCTIONS_WORKER_RUNTIME": "node",
    "KEYCLOAK_URL": "https://keycloak.example.com",
    "KEYCLOAK_REALM": "myrealm",
    "CLIENT_ID": "myclient",
    "CLIENT_SECRET": "supersecret",
    "REDIRECT_URI": "https://myapp.com/api/auth-callback"
  }
}
```

# Custom Domain for Azure Functions

This guide explains how to configure a custom domain for your Azure Function App.

```
+------------------+       +------------------+
|  Custom Domain   | ----> | Azure DNS / CNAME|
+------------------+       +------------------+
                                  |
                                  v
                         +------------------+
                         | Function App     |
                         | myfuncapp.azure  |
                         +------------------+
                                  |
                                  v
                         +------------------+
                         | TLS/SSL          |
                         | HTTPS Enabled    |
                         +------------------+
```

## Prerequisites

- Azure Function App running
- App Service Plan (required for HTTPS with custom domain)
- Domain name registered with access to DNS management



## Step 1: Add Custom Domain in Azure Portal

1. Navigate to your **Function App** in the Azure Portal.
2. Go to **Settings → Custom domains**.
3. Click **+ Add custom domain**.
4. Enter your domain name (e.g., `api.example.com`) and click **Validate**.

## Step 2: Configure DNS Records

### Option A: CNAME (for subdomains, recommended)
- Create a **CNAME record** in your domain registrar:
  - **Host:** `api` (for `api.example.com`)
  - **Points to:** Your Function App’s default domain (e.g., `myfuncapp.azurewebsites.net`)
- Wait for DNS propagation (may take minutes to hours)

### Option B: A Record (for root/apex domain)
- Find your Function App’s IP address (from **Custom domains → Add custom domain**)
- Create an **A record** pointing your root domain to that IP
- Verify domain ownership with the **TXT record** provided by Azure

## Step 3: Enable HTTPS

1. Go to **TLS/SSL settings → Private Key Certificates / HTTPS Only** in the Azure Portal.
2. Choose one of the options:
   - **App Service Managed Certificate** (free, auto-renewed, supports subdomains)
   - **Custom SSL Certificate** (uploaded manually)


## Step 4: Verify

- Access your domain in the browser:

      https://api.example.com

- Check that it resolves to your Function App
- Confirm HTTPS is working if enabled


## Tips

- On **Consumption Plan**, CNAME for subdomains works, but HTTPS with Managed Certificate requires **App Service Plan**
- For root domains (`example.com`), use **A record + TXT verification**

---
