# Azure Functions

Azure Functions is a serverless compute service that lets you run event-driven code without managing infrastructure. 
It's ideal for lightweight, modular tasks triggered by events like 

- HTTP requests,
- timers, or 
- cloud service changes.

Itâ€™s designed for 

- event-driven, 
- stateless, and
- short-lived tasks,

making it ideal for microservices, automation, and reactive workflows.

<img width="1345" height="605" alt="image" src="https://github.com/user-attachments/assets/35c6992e-ddc8-4e4f-806e-87511169604e" />

<img width="1342" height="601" alt="image" src="https://github.com/user-attachments/assets/b157386f-7f59-4570-a9ef-570f9b46640b" />

## What Is Azure Functions?

- Azure Functions is part of **Microsoft Azureâ€™s serverless offerings**. 

- It allows developers to write small pieces of code ("functions") **that execute in response to events**. 

- These functions **automatically scale** and only **consume resources while running**, making them cost-effective and efficient.

## Azure Function Runtime Comparison: Throughput & Latency

| **Runtime**       | **Cold Start Latency** | **Throughput (req/sec)** | **Concurrency**           | **Best Use Case**                                 |
|-------------------|------------------------|---------------------------|----------------------------|---------------------------------------------------|
| **Go (Container)**| ~200â€“400 ms            | ~1,500â€“2,000+             | Excellent (goroutines)     | High-performance APIs, low-latency auth flows     |
| **Node.js 20**    | ~500â€“800 ms            | ~1,000â€“1,500              | Good (event loop)          | OAuth2 flows, PKCE, JWT, async microservices      |
| **Python 3.10+**  | ~800â€“1,500 ms          | ~600â€“1,000                | Moderate (limited async)   | AI/NLP-based auth, readable audit pipelines       |

**Sources**: Microsoft PerfBench Benchmarking, Python Performance Guide

## Runtime Insights

### ðŸŸ¢ Go (via Container)

- Fastest cold starts due to compiled binaries and minimal runtime overhead.

- Highest throughput under load; ideal for stateless, high-frequency auth endpoints.

- Requires custom Dockerfile and container lifecycle management.

- Limited native bindings; use REST or gRPC for Azure integration.

### ðŸŸ¡ Node.js 20

- Improved startup in v20 with better async handling.

- Rich ecosystem for OAuth2, JWT, PKCE, and middleware (Passport.js, Express).

- Native support for Durable Functions, App Insights, and Azure bindings.

- Balanced performance for event-driven flows and modular auth services.

### ðŸ”´ Python 3

- Slower cold starts due to interpreter overhead and dependency loading.

- Throughput improves with horizontal scaling, but latency spikes under load.

- Best suited for AI-enriched authorization, semantic validation, or NLP-based flows.

- Use FastAPI or Flask for modular scaffolds; integrate with Azure AD via Authlib.

## Azure Formula

```
Cost = Execution time Ã— Memory GB Ã— executions
(First 1M requests + 400K GB-seconds free)
```

## Monthly Cost Estimate

| Runtime | Runtime Time             | Estimated Bill |
| ------- | ------------------------ | -------------- |
| Node.js | 10M Ã— 120ms = 1,200,000s | ~$42           |
| Go      | 10M Ã— 50ms = 500,000s    | **~$17**       |

> Go saves ~60% on compute due to speed + memory efficiency

## ðŸ§  Summary

| Category   | Node   | Go          |
| ---------- | ------ | ----------- |
| Cold start | âœ… Good | âœ… **Great** |
| Memory     | Medium | **Low**     |
| CPU speed  | Good   | **Fast**    |
| Cost       | ~$42   | **~$17**    |

> ðŸ‘‰ Go can cut Azure Function cost by 40â€“70% for compute-heavy workloads

